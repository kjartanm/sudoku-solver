// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ortools/glop/parameters.proto

#include "ortools/glop/parameters.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
namespace operations_research {
namespace glop {
class GlopParametersDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<GlopParameters> _instance;
} _GlopParameters_default_instance_;
}  // namespace glop
}  // namespace operations_research
static void InitDefaultsscc_info_GlopParameters_ortools_2fglop_2fparameters_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::operations_research::glop::_GlopParameters_default_instance_;
    new (ptr) ::operations_research::glop::GlopParameters();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::operations_research::glop::GlopParameters::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_GlopParameters_ortools_2fglop_2fparameters_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_GlopParameters_ortools_2fglop_2fparameters_2eproto}, {}};

static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_ortools_2fglop_2fparameters_2eproto[1];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_ortools_2fglop_2fparameters_2eproto[4];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_ortools_2fglop_2fparameters_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_ortools_2fglop_2fparameters_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, scaling_method_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, feasibility_rule_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, optimization_rule_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, normalize_using_column_norm_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, use_nested_pricing_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, refactorization_threshold_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, recompute_reduced_costs_threshold_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, recompute_edges_norm_threshold_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, primal_feasibility_tolerance_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, dual_feasibility_tolerance_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, ratio_test_zero_threshold_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, harris_tolerance_ratio_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, small_pivot_threshold_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, minimum_acceptable_pivot_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, drop_tolerance_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, use_scaling_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, initial_basis_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, use_transposed_matrix_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, basis_refactorization_period_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, solve_dual_problem_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, dualizer_threshold_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, solution_feasibility_tolerance_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, provide_strong_optimal_guarantee_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, change_status_to_imprecise_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, max_number_of_reoptimizations_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, lu_factorization_pivot_threshold_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, max_time_in_seconds_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, max_deterministic_time_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, max_number_of_iterations_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, markowitz_zlatev_parameter_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, markowitz_singularity_threshold_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, use_dual_simplex_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, allow_simplex_algorithm_change_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, devex_weights_reset_period_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, use_preprocessing_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, use_middle_product_form_update_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, initialize_devex_with_column_norms_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, exploit_singleton_column_in_initial_basis_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, dual_small_pivot_threshold_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, preprocessor_zero_tolerance_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, objective_lower_limit_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, objective_upper_limit_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, degenerate_ministep_factor_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, random_seed_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, num_omp_threads_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, perturb_costs_in_dual_simplex_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, relative_cost_perturbation_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, relative_max_cost_perturbation_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, initial_condition_number_threshold_),
  3,
  4,
  5,
  12,
  13,
  6,
  7,
  8,
  9,
  10,
  11,
  17,
  18,
  19,
  44,
  14,
  16,
  15,
  20,
  21,
  22,
  23,
  32,
  33,
  47,
  24,
  25,
  43,
  26,
  28,
  27,
  0,
  1,
  29,
  34,
  35,
  30,
  31,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  2,
  45,
  46,
  48,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 54, sizeof(::operations_research::glop::GlopParameters)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::operations_research::glop::_GlopParameters_default_instance_),
};

const char descriptor_table_protodef_ortools_2fglop_2fparameters_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\035ortools/glop/parameters.proto\022\030operati"
  "ons_research.glop\"\230\024\n\016GlopParameters\022`\n\016"
  "scaling_method\0309 \001(\01629.operations_resear"
  "ch.glop.GlopParameters.ScalingAlgorithm:"
  "\rEQUILIBRATION\022]\n\020feasibility_rule\030\001 \001(\016"
  "24.operations_research.glop.GlopParamete"
  "rs.PricingRule:\rSTEEPEST_EDGE\022^\n\021optimiz"
  "ation_rule\030\002 \001(\01624.operations_research.g"
  "lop.GlopParameters.PricingRule:\rSTEEPEST"
  "_EDGE\022)\n\033normalize_using_column_norm\030\004 \001"
  "(\010:\004true\022 \n\022use_nested_pricing\030\005 \001(\010:\004tr"
  "ue\022(\n\031refactorization_threshold\030\006 \001(\001:\0051"
  "e-09\0220\n!recompute_reduced_costs_threshol"
  "d\030\010 \001(\001:\0051e-08\022+\n\036recompute_edges_norm_t"
  "hreshold\030\t \001(\001:\003100\022+\n\034primal_feasibilit"
  "y_tolerance\030\n \001(\001:\0051e-08\022)\n\032dual_feasibi"
  "lity_tolerance\030\013 \001(\001:\0051e-08\022(\n\031ratio_tes"
  "t_zero_threshold\030\014 \001(\001:\0051e-09\022#\n\026harris_"
  "tolerance_ratio\030\r \001(\001:\0030.5\022$\n\025small_pivo"
  "t_threshold\030\016 \001(\001:\0051e-06\022\'\n\030minimum_acce"
  "ptable_pivot\030\017 \001(\001:\0051e-06\022\035\n\016drop_tolera"
  "nce\0304 \001(\001:\0051e-14\022\031\n\013use_scaling\030\020 \001(\010:\004t"
  "rue\022a\n\rinitial_basis\030\021 \001(\0162>.operations_"
  "research.glop.GlopParameters.InitialBasi"
  "sHeuristic:\nTRIANGULAR\022#\n\025use_transposed"
  "_matrix\030\022 \001(\010:\004true\022(\n\034basis_refactoriza"
  "tion_period\030\023 \001(\005:\00264\022f\n\022solve_dual_prob"
  "lem\030\024 \001(\01627.operations_research.glop.Glo"
  "pParameters.SolverBehavior:\021LET_SOLVER_D"
  "ECIDE\022\037\n\022dualizer_threshold\030\025 \001(\001:\0031.5\022-"
  "\n\036solution_feasibility_tolerance\030\026 \001(\001:\005"
  "1e-06\022.\n provide_strong_optimal_guarante"
  "e\030\030 \001(\010:\004true\022(\n\032change_status_to_imprec"
  "ise\030: \001(\010:\004true\022)\n\035max_number_of_reoptim"
  "izations\0308 \001(\001:\00240\022.\n lu_factorization_p"
  "ivot_threshold\030\031 \001(\001:\0040.01\022 \n\023max_time_i"
  "n_seconds\030\032 \001(\001:\003inf\022#\n\026max_deterministi"
  "c_time\030- \001(\001:\003inf\022$\n\030max_number_of_itera"
  "tions\030\033 \001(\003:\002-1\022%\n\032markowitz_zlatev_para"
  "meter\030\035 \001(\005:\0013\022.\n\037markowitz_singularity_"
  "threshold\030\036 \001(\001:\0051e-15\022\037\n\020use_dual_simpl"
  "ex\030\037 \001(\010:\005false\022-\n\036allow_simplex_algorit"
  "hm_change\030  \001(\010:\005false\022\'\n\032devex_weights_"
  "reset_period\030! \001(\005:\003150\022\037\n\021use_preproces"
  "sing\030\" \001(\010:\004true\022,\n\036use_middle_product_f"
  "orm_update\030# \001(\010:\004true\0220\n\"initialize_dev"
  "ex_with_column_norms\030$ \001(\010:\004true\0227\n)expl"
  "oit_singleton_column_in_initial_basis\030% "
  "\001(\010:\004true\022*\n\032dual_small_pivot_threshold\030"
  "& \001(\001:\0060.0001\022*\n\033preprocessor_zero_toler"
  "ance\030\' \001(\001:\0051e-09\022#\n\025objective_lower_lim"
  "it\030( \001(\001:\004-inf\022\"\n\025objective_upper_limit\030"
  ") \001(\001:\003inf\022(\n\032degenerate_ministep_factor"
  "\030* \001(\001:\0040.01\022\026\n\013random_seed\030+ \001(\005:\0011\022\032\n\017"
  "num_omp_threads\030, \001(\005:\0011\022,\n\035perturb_cost"
  "s_in_dual_simplex\0305 \001(\010:\005false\022)\n\032relati"
  "ve_cost_perturbation\0306 \001(\001:\0051e-05\022-\n\036rel"
  "ative_max_cost_perturbation\0307 \001(\001:\0051e-07"
  "\0221\n\"initial_condition_number_threshold\030;"
  " \001(\001:\0051e+50\"F\n\020ScalingAlgorithm\022\013\n\007DEFAU"
  "LT\020\000\022\021\n\rEQUILIBRATION\020\001\022\022\n\016LINEAR_PROGRA"
  "M\020\002\"D\n\016SolverBehavior\022\r\n\tALWAYS_DO\020\000\022\014\n\010"
  "NEVER_DO\020\001\022\025\n\021LET_SOLVER_DECIDE\020\002\"8\n\013Pri"
  "cingRule\022\013\n\007DANTZIG\020\000\022\021\n\rSTEEPEST_EDGE\020\001"
  "\022\t\n\005DEVEX\020\002\"G\n\025InitialBasisHeuristic\022\010\n\004"
  "NONE\020\000\022\t\n\005BIXBY\020\001\022\016\n\nTRIANGULAR\020\002\022\t\n\005MAR"
  "OS\020\003"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_ortools_2fglop_2fparameters_2eproto_deps[1] = {
};
static ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase*const descriptor_table_ortools_2fglop_2fparameters_2eproto_sccs[1] = {
  &scc_info_GlopParameters_ortools_2fglop_2fparameters_2eproto.base,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_ortools_2fglop_2fparameters_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ortools_2fglop_2fparameters_2eproto = {
  false, false, descriptor_table_protodef_ortools_2fglop_2fparameters_2eproto, "ortools/glop/parameters.proto", 2644,
  &descriptor_table_ortools_2fglop_2fparameters_2eproto_once, descriptor_table_ortools_2fglop_2fparameters_2eproto_sccs, descriptor_table_ortools_2fglop_2fparameters_2eproto_deps, 1, 0,
  schemas, file_default_instances, TableStruct_ortools_2fglop_2fparameters_2eproto::offsets,
  file_level_metadata_ortools_2fglop_2fparameters_2eproto, 1, file_level_enum_descriptors_ortools_2fglop_2fparameters_2eproto, file_level_service_descriptors_ortools_2fglop_2fparameters_2eproto,
};

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_ortools_2fglop_2fparameters_2eproto = (static_cast<void>(::PROTOBUF_NAMESPACE_ID::internal::AddDescriptors(&descriptor_table_ortools_2fglop_2fparameters_2eproto)), true);
namespace operations_research {
namespace glop {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GlopParameters_ScalingAlgorithm_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ortools_2fglop_2fparameters_2eproto);
  return file_level_enum_descriptors_ortools_2fglop_2fparameters_2eproto[0];
}
bool GlopParameters_ScalingAlgorithm_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr GlopParameters_ScalingAlgorithm GlopParameters::DEFAULT;
constexpr GlopParameters_ScalingAlgorithm GlopParameters::EQUILIBRATION;
constexpr GlopParameters_ScalingAlgorithm GlopParameters::LINEAR_PROGRAM;
constexpr GlopParameters_ScalingAlgorithm GlopParameters::ScalingAlgorithm_MIN;
constexpr GlopParameters_ScalingAlgorithm GlopParameters::ScalingAlgorithm_MAX;
constexpr int GlopParameters::ScalingAlgorithm_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GlopParameters_SolverBehavior_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ortools_2fglop_2fparameters_2eproto);
  return file_level_enum_descriptors_ortools_2fglop_2fparameters_2eproto[1];
}
bool GlopParameters_SolverBehavior_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr GlopParameters_SolverBehavior GlopParameters::ALWAYS_DO;
constexpr GlopParameters_SolverBehavior GlopParameters::NEVER_DO;
constexpr GlopParameters_SolverBehavior GlopParameters::LET_SOLVER_DECIDE;
constexpr GlopParameters_SolverBehavior GlopParameters::SolverBehavior_MIN;
constexpr GlopParameters_SolverBehavior GlopParameters::SolverBehavior_MAX;
constexpr int GlopParameters::SolverBehavior_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GlopParameters_PricingRule_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ortools_2fglop_2fparameters_2eproto);
  return file_level_enum_descriptors_ortools_2fglop_2fparameters_2eproto[2];
}
bool GlopParameters_PricingRule_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr GlopParameters_PricingRule GlopParameters::DANTZIG;
constexpr GlopParameters_PricingRule GlopParameters::STEEPEST_EDGE;
constexpr GlopParameters_PricingRule GlopParameters::DEVEX;
constexpr GlopParameters_PricingRule GlopParameters::PricingRule_MIN;
constexpr GlopParameters_PricingRule GlopParameters::PricingRule_MAX;
constexpr int GlopParameters::PricingRule_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GlopParameters_InitialBasisHeuristic_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ortools_2fglop_2fparameters_2eproto);
  return file_level_enum_descriptors_ortools_2fglop_2fparameters_2eproto[3];
}
bool GlopParameters_InitialBasisHeuristic_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr GlopParameters_InitialBasisHeuristic GlopParameters::NONE;
constexpr GlopParameters_InitialBasisHeuristic GlopParameters::BIXBY;
constexpr GlopParameters_InitialBasisHeuristic GlopParameters::TRIANGULAR;
constexpr GlopParameters_InitialBasisHeuristic GlopParameters::MAROS;
constexpr GlopParameters_InitialBasisHeuristic GlopParameters::InitialBasisHeuristic_MIN;
constexpr GlopParameters_InitialBasisHeuristic GlopParameters::InitialBasisHeuristic_MAX;
constexpr int GlopParameters::InitialBasisHeuristic_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)

// ===================================================================

void GlopParameters::InitAsDefaultInstance() {
}
class GlopParameters::_Internal {
 public:
  using HasBits = decltype(std::declval<GlopParameters>()._has_bits_);
  static void set_has_scaling_method(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_feasibility_rule(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_optimization_rule(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_normalize_using_column_norm(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_use_nested_pricing(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_refactorization_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_recompute_reduced_costs_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_recompute_edges_norm_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_primal_feasibility_tolerance(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_dual_feasibility_tolerance(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_ratio_test_zero_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_harris_tolerance_ratio(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_small_pivot_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_minimum_acceptable_pivot(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_drop_tolerance(HasBits* has_bits) {
    (*has_bits)[1] |= 4096u;
  }
  static void set_has_use_scaling(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_initial_basis(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_use_transposed_matrix(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_basis_refactorization_period(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_solve_dual_problem(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_dualizer_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_solution_feasibility_tolerance(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_provide_strong_optimal_guarantee(HasBits* has_bits) {
    (*has_bits)[1] |= 1u;
  }
  static void set_has_change_status_to_imprecise(HasBits* has_bits) {
    (*has_bits)[1] |= 2u;
  }
  static void set_has_max_number_of_reoptimizations(HasBits* has_bits) {
    (*has_bits)[1] |= 32768u;
  }
  static void set_has_lu_factorization_pivot_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_max_time_in_seconds(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_max_deterministic_time(HasBits* has_bits) {
    (*has_bits)[1] |= 2048u;
  }
  static void set_has_max_number_of_iterations(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_markowitz_zlatev_parameter(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static void set_has_markowitz_singularity_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_use_dual_simplex(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_allow_simplex_algorithm_change(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_devex_weights_reset_period(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static void set_has_use_preprocessing(HasBits* has_bits) {
    (*has_bits)[1] |= 4u;
  }
  static void set_has_use_middle_product_form_update(HasBits* has_bits) {
    (*has_bits)[1] |= 8u;
  }
  static void set_has_initialize_devex_with_column_norms(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static void set_has_exploit_singleton_column_in_initial_basis(HasBits* has_bits) {
    (*has_bits)[0] |= 2147483648u;
  }
  static void set_has_dual_small_pivot_threshold(HasBits* has_bits) {
    (*has_bits)[1] |= 16u;
  }
  static void set_has_preprocessor_zero_tolerance(HasBits* has_bits) {
    (*has_bits)[1] |= 32u;
  }
  static void set_has_objective_lower_limit(HasBits* has_bits) {
    (*has_bits)[1] |= 64u;
  }
  static void set_has_objective_upper_limit(HasBits* has_bits) {
    (*has_bits)[1] |= 128u;
  }
  static void set_has_degenerate_ministep_factor(HasBits* has_bits) {
    (*has_bits)[1] |= 256u;
  }
  static void set_has_random_seed(HasBits* has_bits) {
    (*has_bits)[1] |= 512u;
  }
  static void set_has_num_omp_threads(HasBits* has_bits) {
    (*has_bits)[1] |= 1024u;
  }
  static void set_has_perturb_costs_in_dual_simplex(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_relative_cost_perturbation(HasBits* has_bits) {
    (*has_bits)[1] |= 8192u;
  }
  static void set_has_relative_max_cost_perturbation(HasBits* has_bits) {
    (*has_bits)[1] |= 16384u;
  }
  static void set_has_initial_condition_number_threshold(HasBits* has_bits) {
    (*has_bits)[1] |= 65536u;
  }
};

GlopParameters::GlopParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:operations_research.glop.GlopParameters)
}
GlopParameters::GlopParameters(const GlopParameters& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&use_dual_simplex_, &from.use_dual_simplex_,
    static_cast<size_t>(reinterpret_cast<char*>(&initial_condition_number_threshold_) -
    reinterpret_cast<char*>(&use_dual_simplex_)) + sizeof(initial_condition_number_threshold_));
  // @@protoc_insertion_point(copy_constructor:operations_research.glop.GlopParameters)
}

void GlopParameters::SharedCtor() {
  ::memset(&use_dual_simplex_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&perturb_costs_in_dual_simplex_) -
      reinterpret_cast<char*>(&use_dual_simplex_)) + sizeof(perturb_costs_in_dual_simplex_));
  scaling_method_ = 1;
  feasibility_rule_ = 1;
  optimization_rule_ = 1;
  refactorization_threshold_ = 1e-09;
  recompute_reduced_costs_threshold_ = 1e-08;
  recompute_edges_norm_threshold_ = 100;
  primal_feasibility_tolerance_ = 1e-08;
  dual_feasibility_tolerance_ = 1e-08;
  ratio_test_zero_threshold_ = 1e-09;
  normalize_using_column_norm_ = true;
  use_nested_pricing_ = true;
  use_scaling_ = true;
  use_transposed_matrix_ = true;
  initial_basis_ = 2;
  harris_tolerance_ratio_ = 0.5;
  small_pivot_threshold_ = 1e-06;
  minimum_acceptable_pivot_ = 1e-06;
  basis_refactorization_period_ = 64;
  solve_dual_problem_ = 2;
  dualizer_threshold_ = 1.5;
  solution_feasibility_tolerance_ = 1e-06;
  lu_factorization_pivot_threshold_ = 0.01;
  max_time_in_seconds_ = std::numeric_limits<double>::infinity();
  max_number_of_iterations_ = PROTOBUF_LONGLONG(-1);
  markowitz_singularity_threshold_ = 1e-15;
  markowitz_zlatev_parameter_ = 3;
  devex_weights_reset_period_ = 150;
  initialize_devex_with_column_norms_ = true;
  exploit_singleton_column_in_initial_basis_ = true;
  provide_strong_optimal_guarantee_ = true;
  change_status_to_imprecise_ = true;
  use_preprocessing_ = true;
  use_middle_product_form_update_ = true;
  dual_small_pivot_threshold_ = 0.0001;
  preprocessor_zero_tolerance_ = 1e-09;
  objective_lower_limit_ = -std::numeric_limits<double>::infinity();
  objective_upper_limit_ = std::numeric_limits<double>::infinity();
  degenerate_ministep_factor_ = 0.01;
  random_seed_ = 1;
  num_omp_threads_ = 1;
  max_deterministic_time_ = std::numeric_limits<double>::infinity();
  drop_tolerance_ = 1e-14;
  relative_cost_perturbation_ = 1e-05;
  relative_max_cost_perturbation_ = 1e-07;
  max_number_of_reoptimizations_ = 40;
  initial_condition_number_threshold_ = 1e+50;
}

GlopParameters::~GlopParameters() {
  // @@protoc_insertion_point(destructor:operations_research.glop.GlopParameters)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void GlopParameters::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void GlopParameters::ArenaDtor(void* object) {
  GlopParameters* _this = reinterpret_cast< GlopParameters* >(object);
  (void)_this;
}
void GlopParameters::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GlopParameters::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const GlopParameters& GlopParameters::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_GlopParameters_ortools_2fglop_2fparameters_2eproto.base);
  return *internal_default_instance();
}


void GlopParameters::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.glop.GlopParameters)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&use_dual_simplex_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&perturb_costs_in_dual_simplex_) -
      reinterpret_cast<char*>(&use_dual_simplex_)) + sizeof(perturb_costs_in_dual_simplex_));
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000f8u) {
    scaling_method_ = 1;
    feasibility_rule_ = 1;
    optimization_rule_ = 1;
    refactorization_threshold_ = 1e-09;
    recompute_reduced_costs_threshold_ = 1e-08;
  }
  if (cached_has_bits & 0x0000ff00u) {
    recompute_edges_norm_threshold_ = 100;
    primal_feasibility_tolerance_ = 1e-08;
    dual_feasibility_tolerance_ = 1e-08;
    ratio_test_zero_threshold_ = 1e-09;
    normalize_using_column_norm_ = true;
    use_nested_pricing_ = true;
    use_scaling_ = true;
    use_transposed_matrix_ = true;
  }
  if (cached_has_bits & 0x00ff0000u) {
    initial_basis_ = 2;
    harris_tolerance_ratio_ = 0.5;
    small_pivot_threshold_ = 1e-06;
    minimum_acceptable_pivot_ = 1e-06;
    basis_refactorization_period_ = 64;
    solve_dual_problem_ = 2;
    dualizer_threshold_ = 1.5;
    solution_feasibility_tolerance_ = 1e-06;
  }
  if (cached_has_bits & 0xff000000u) {
    lu_factorization_pivot_threshold_ = 0.01;
    max_time_in_seconds_ = std::numeric_limits<double>::infinity();
    max_number_of_iterations_ = PROTOBUF_LONGLONG(-1);
    markowitz_singularity_threshold_ = 1e-15;
    markowitz_zlatev_parameter_ = 3;
    devex_weights_reset_period_ = 150;
    initialize_devex_with_column_norms_ = true;
    exploit_singleton_column_in_initial_basis_ = true;
  }
  cached_has_bits = _has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    provide_strong_optimal_guarantee_ = true;
    change_status_to_imprecise_ = true;
    use_preprocessing_ = true;
    use_middle_product_form_update_ = true;
    dual_small_pivot_threshold_ = 0.0001;
    preprocessor_zero_tolerance_ = 1e-09;
    objective_lower_limit_ = -std::numeric_limits<double>::infinity();
    objective_upper_limit_ = std::numeric_limits<double>::infinity();
  }
  if (cached_has_bits & 0x0000ff00u) {
    degenerate_ministep_factor_ = 0.01;
    random_seed_ = 1;
    num_omp_threads_ = 1;
    max_deterministic_time_ = std::numeric_limits<double>::infinity();
    drop_tolerance_ = 1e-14;
    relative_cost_perturbation_ = 1e-05;
    relative_max_cost_perturbation_ = 1e-07;
    max_number_of_reoptimizations_ = 40;
  }
  initial_condition_number_threshold_ = 1e+50;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GlopParameters::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .operations_research.glop.GlopParameters.PricingRule feasibility_rule = 1 [default = STEEPEST_EDGE];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::operations_research::glop::GlopParameters_PricingRule_IsValid(val))) {
            _internal_set_feasibility_rule(static_cast<::operations_research::glop::GlopParameters_PricingRule>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .operations_research.glop.GlopParameters.PricingRule optimization_rule = 2 [default = STEEPEST_EDGE];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::operations_research::glop::GlopParameters_PricingRule_IsValid(val))) {
            _internal_set_optimization_rule(static_cast<::operations_research::glop::GlopParameters_PricingRule>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional bool normalize_using_column_norm = 4 [default = true];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_normalize_using_column_norm(&_has_bits_);
          normalize_using_column_norm_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool use_nested_pricing = 5 [default = true];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_use_nested_pricing(&_has_bits_);
          use_nested_pricing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional double refactorization_threshold = 6 [default = 1e-09];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 49)) {
          _Internal::set_has_refactorization_threshold(&_has_bits_);
          refactorization_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double recompute_reduced_costs_threshold = 8 [default = 1e-08];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 65)) {
          _Internal::set_has_recompute_reduced_costs_threshold(&_has_bits_);
          recompute_reduced_costs_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double recompute_edges_norm_threshold = 9 [default = 100];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 73)) {
          _Internal::set_has_recompute_edges_norm_threshold(&_has_bits_);
          recompute_edges_norm_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double primal_feasibility_tolerance = 10 [default = 1e-08];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 81)) {
          _Internal::set_has_primal_feasibility_tolerance(&_has_bits_);
          primal_feasibility_tolerance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double dual_feasibility_tolerance = 11 [default = 1e-08];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 89)) {
          _Internal::set_has_dual_feasibility_tolerance(&_has_bits_);
          dual_feasibility_tolerance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double ratio_test_zero_threshold = 12 [default = 1e-09];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 97)) {
          _Internal::set_has_ratio_test_zero_threshold(&_has_bits_);
          ratio_test_zero_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double harris_tolerance_ratio = 13 [default = 0.5];
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 105)) {
          _Internal::set_has_harris_tolerance_ratio(&_has_bits_);
          harris_tolerance_ratio_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double small_pivot_threshold = 14 [default = 1e-06];
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 113)) {
          _Internal::set_has_small_pivot_threshold(&_has_bits_);
          small_pivot_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double minimum_acceptable_pivot = 15 [default = 1e-06];
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 121)) {
          _Internal::set_has_minimum_acceptable_pivot(&_has_bits_);
          minimum_acceptable_pivot_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional bool use_scaling = 16 [default = true];
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 128)) {
          _Internal::set_has_use_scaling(&_has_bits_);
          use_scaling_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .operations_research.glop.GlopParameters.InitialBasisHeuristic initial_basis = 17 [default = TRIANGULAR];
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 136)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::operations_research::glop::GlopParameters_InitialBasisHeuristic_IsValid(val))) {
            _internal_set_initial_basis(static_cast<::operations_research::glop::GlopParameters_InitialBasisHeuristic>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(17, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional bool use_transposed_matrix = 18 [default = true];
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 144)) {
          _Internal::set_has_use_transposed_matrix(&_has_bits_);
          use_transposed_matrix_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 basis_refactorization_period = 19 [default = 64];
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 152)) {
          _Internal::set_has_basis_refactorization_period(&_has_bits_);
          basis_refactorization_period_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .operations_research.glop.GlopParameters.SolverBehavior solve_dual_problem = 20 [default = LET_SOLVER_DECIDE];
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 160)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::operations_research::glop::GlopParameters_SolverBehavior_IsValid(val))) {
            _internal_set_solve_dual_problem(static_cast<::operations_research::glop::GlopParameters_SolverBehavior>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(20, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional double dualizer_threshold = 21 [default = 1.5];
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 169)) {
          _Internal::set_has_dualizer_threshold(&_has_bits_);
          dualizer_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double solution_feasibility_tolerance = 22 [default = 1e-06];
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 177)) {
          _Internal::set_has_solution_feasibility_tolerance(&_has_bits_);
          solution_feasibility_tolerance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional bool provide_strong_optimal_guarantee = 24 [default = true];
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 192)) {
          _Internal::set_has_provide_strong_optimal_guarantee(&_has_bits_);
          provide_strong_optimal_guarantee_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional double lu_factorization_pivot_threshold = 25 [default = 0.01];
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 201)) {
          _Internal::set_has_lu_factorization_pivot_threshold(&_has_bits_);
          lu_factorization_pivot_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double max_time_in_seconds = 26 [default = inf];
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 209)) {
          _Internal::set_has_max_time_in_seconds(&_has_bits_);
          max_time_in_seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional int64 max_number_of_iterations = 27 [default = -1];
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 216)) {
          _Internal::set_has_max_number_of_iterations(&_has_bits_);
          max_number_of_iterations_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 markowitz_zlatev_parameter = 29 [default = 3];
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 232)) {
          _Internal::set_has_markowitz_zlatev_parameter(&_has_bits_);
          markowitz_zlatev_parameter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional double markowitz_singularity_threshold = 30 [default = 1e-15];
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 241)) {
          _Internal::set_has_markowitz_singularity_threshold(&_has_bits_);
          markowitz_singularity_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional bool use_dual_simplex = 31 [default = false];
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 248)) {
          _Internal::set_has_use_dual_simplex(&_has_bits_);
          use_dual_simplex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool allow_simplex_algorithm_change = 32 [default = false];
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 0)) {
          _Internal::set_has_allow_simplex_algorithm_change(&_has_bits_);
          allow_simplex_algorithm_change_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 devex_weights_reset_period = 33 [default = 150];
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_devex_weights_reset_period(&_has_bits_);
          devex_weights_reset_period_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool use_preprocessing = 34 [default = true];
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_use_preprocessing(&_has_bits_);
          use_preprocessing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool use_middle_product_form_update = 35 [default = true];
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_use_middle_product_form_update(&_has_bits_);
          use_middle_product_form_update_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool initialize_devex_with_column_norms = 36 [default = true];
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_initialize_devex_with_column_norms(&_has_bits_);
          initialize_devex_with_column_norms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool exploit_singleton_column_in_initial_basis = 37 [default = true];
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_exploit_singleton_column_in_initial_basis(&_has_bits_);
          exploit_singleton_column_in_initial_basis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional double dual_small_pivot_threshold = 38 [default = 0.0001];
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 49)) {
          _Internal::set_has_dual_small_pivot_threshold(&_has_bits_);
          dual_small_pivot_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double preprocessor_zero_tolerance = 39 [default = 1e-09];
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 57)) {
          _Internal::set_has_preprocessor_zero_tolerance(&_has_bits_);
          preprocessor_zero_tolerance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double objective_lower_limit = 40 [default = -inf];
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 65)) {
          _Internal::set_has_objective_lower_limit(&_has_bits_);
          objective_lower_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double objective_upper_limit = 41 [default = inf];
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 73)) {
          _Internal::set_has_objective_upper_limit(&_has_bits_);
          objective_upper_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double degenerate_ministep_factor = 42 [default = 0.01];
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 81)) {
          _Internal::set_has_degenerate_ministep_factor(&_has_bits_);
          degenerate_ministep_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional int32 random_seed = 43 [default = 1];
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_random_seed(&_has_bits_);
          random_seed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 num_omp_threads = 44 [default = 1];
      case 44:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_num_omp_threads(&_has_bits_);
          num_omp_threads_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional double max_deterministic_time = 45 [default = inf];
      case 45:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 105)) {
          _Internal::set_has_max_deterministic_time(&_has_bits_);
          max_deterministic_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double drop_tolerance = 52 [default = 1e-14];
      case 52:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 161)) {
          _Internal::set_has_drop_tolerance(&_has_bits_);
          drop_tolerance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional bool perturb_costs_in_dual_simplex = 53 [default = false];
      case 53:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 168)) {
          _Internal::set_has_perturb_costs_in_dual_simplex(&_has_bits_);
          perturb_costs_in_dual_simplex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional double relative_cost_perturbation = 54 [default = 1e-05];
      case 54:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 177)) {
          _Internal::set_has_relative_cost_perturbation(&_has_bits_);
          relative_cost_perturbation_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double relative_max_cost_perturbation = 55 [default = 1e-07];
      case 55:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 185)) {
          _Internal::set_has_relative_max_cost_perturbation(&_has_bits_);
          relative_max_cost_perturbation_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double max_number_of_reoptimizations = 56 [default = 40];
      case 56:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 193)) {
          _Internal::set_has_max_number_of_reoptimizations(&_has_bits_);
          max_number_of_reoptimizations_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional .operations_research.glop.GlopParameters.ScalingAlgorithm scaling_method = 57 [default = EQUILIBRATION];
      case 57:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 200)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::operations_research::glop::GlopParameters_ScalingAlgorithm_IsValid(val))) {
            _internal_set_scaling_method(static_cast<::operations_research::glop::GlopParameters_ScalingAlgorithm>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(57, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional bool change_status_to_imprecise = 58 [default = true];
      case 58:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 208)) {
          _Internal::set_has_change_status_to_imprecise(&_has_bits_);
          change_status_to_imprecise_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional double initial_condition_number_threshold = 59 [default = 1e+50];
      case 59:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 217)) {
          _Internal::set_has_initial_condition_number_threshold(&_has_bits_);
          initial_condition_number_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* GlopParameters::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.glop.GlopParameters)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .operations_research.glop.GlopParameters.PricingRule feasibility_rule = 1 [default = STEEPEST_EDGE];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_feasibility_rule(), target);
  }

  // optional .operations_research.glop.GlopParameters.PricingRule optimization_rule = 2 [default = STEEPEST_EDGE];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_optimization_rule(), target);
  }

  // optional bool normalize_using_column_norm = 4 [default = true];
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_normalize_using_column_norm(), target);
  }

  // optional bool use_nested_pricing = 5 [default = true];
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_use_nested_pricing(), target);
  }

  // optional double refactorization_threshold = 6 [default = 1e-09];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(6, this->_internal_refactorization_threshold(), target);
  }

  // optional double recompute_reduced_costs_threshold = 8 [default = 1e-08];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(8, this->_internal_recompute_reduced_costs_threshold(), target);
  }

  // optional double recompute_edges_norm_threshold = 9 [default = 100];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(9, this->_internal_recompute_edges_norm_threshold(), target);
  }

  // optional double primal_feasibility_tolerance = 10 [default = 1e-08];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(10, this->_internal_primal_feasibility_tolerance(), target);
  }

  // optional double dual_feasibility_tolerance = 11 [default = 1e-08];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(11, this->_internal_dual_feasibility_tolerance(), target);
  }

  // optional double ratio_test_zero_threshold = 12 [default = 1e-09];
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(12, this->_internal_ratio_test_zero_threshold(), target);
  }

  // optional double harris_tolerance_ratio = 13 [default = 0.5];
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(13, this->_internal_harris_tolerance_ratio(), target);
  }

  // optional double small_pivot_threshold = 14 [default = 1e-06];
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(14, this->_internal_small_pivot_threshold(), target);
  }

  // optional double minimum_acceptable_pivot = 15 [default = 1e-06];
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(15, this->_internal_minimum_acceptable_pivot(), target);
  }

  // optional bool use_scaling = 16 [default = true];
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(16, this->_internal_use_scaling(), target);
  }

  // optional .operations_research.glop.GlopParameters.InitialBasisHeuristic initial_basis = 17 [default = TRIANGULAR];
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      17, this->_internal_initial_basis(), target);
  }

  // optional bool use_transposed_matrix = 18 [default = true];
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(18, this->_internal_use_transposed_matrix(), target);
  }

  // optional int32 basis_refactorization_period = 19 [default = 64];
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(19, this->_internal_basis_refactorization_period(), target);
  }

  // optional .operations_research.glop.GlopParameters.SolverBehavior solve_dual_problem = 20 [default = LET_SOLVER_DECIDE];
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      20, this->_internal_solve_dual_problem(), target);
  }

  // optional double dualizer_threshold = 21 [default = 1.5];
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(21, this->_internal_dualizer_threshold(), target);
  }

  // optional double solution_feasibility_tolerance = 22 [default = 1e-06];
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(22, this->_internal_solution_feasibility_tolerance(), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional bool provide_strong_optimal_guarantee = 24 [default = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(24, this->_internal_provide_strong_optimal_guarantee(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional double lu_factorization_pivot_threshold = 25 [default = 0.01];
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(25, this->_internal_lu_factorization_pivot_threshold(), target);
  }

  // optional double max_time_in_seconds = 26 [default = inf];
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(26, this->_internal_max_time_in_seconds(), target);
  }

  // optional int64 max_number_of_iterations = 27 [default = -1];
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(27, this->_internal_max_number_of_iterations(), target);
  }

  // optional int32 markowitz_zlatev_parameter = 29 [default = 3];
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(29, this->_internal_markowitz_zlatev_parameter(), target);
  }

  // optional double markowitz_singularity_threshold = 30 [default = 1e-15];
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(30, this->_internal_markowitz_singularity_threshold(), target);
  }

  // optional bool use_dual_simplex = 31 [default = false];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(31, this->_internal_use_dual_simplex(), target);
  }

  // optional bool allow_simplex_algorithm_change = 32 [default = false];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(32, this->_internal_allow_simplex_algorithm_change(), target);
  }

  // optional int32 devex_weights_reset_period = 33 [default = 150];
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(33, this->_internal_devex_weights_reset_period(), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional bool use_preprocessing = 34 [default = true];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(34, this->_internal_use_preprocessing(), target);
  }

  // optional bool use_middle_product_form_update = 35 [default = true];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(35, this->_internal_use_middle_product_form_update(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional bool initialize_devex_with_column_norms = 36 [default = true];
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(36, this->_internal_initialize_devex_with_column_norms(), target);
  }

  // optional bool exploit_singleton_column_in_initial_basis = 37 [default = true];
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(37, this->_internal_exploit_singleton_column_in_initial_basis(), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional double dual_small_pivot_threshold = 38 [default = 0.0001];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(38, this->_internal_dual_small_pivot_threshold(), target);
  }

  // optional double preprocessor_zero_tolerance = 39 [default = 1e-09];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(39, this->_internal_preprocessor_zero_tolerance(), target);
  }

  // optional double objective_lower_limit = 40 [default = -inf];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(40, this->_internal_objective_lower_limit(), target);
  }

  // optional double objective_upper_limit = 41 [default = inf];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(41, this->_internal_objective_upper_limit(), target);
  }

  // optional double degenerate_ministep_factor = 42 [default = 0.01];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(42, this->_internal_degenerate_ministep_factor(), target);
  }

  // optional int32 random_seed = 43 [default = 1];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(43, this->_internal_random_seed(), target);
  }

  // optional int32 num_omp_threads = 44 [default = 1];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(44, this->_internal_num_omp_threads(), target);
  }

  // optional double max_deterministic_time = 45 [default = inf];
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(45, this->_internal_max_deterministic_time(), target);
  }

  // optional double drop_tolerance = 52 [default = 1e-14];
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(52, this->_internal_drop_tolerance(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional bool perturb_costs_in_dual_simplex = 53 [default = false];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(53, this->_internal_perturb_costs_in_dual_simplex(), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional double relative_cost_perturbation = 54 [default = 1e-05];
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(54, this->_internal_relative_cost_perturbation(), target);
  }

  // optional double relative_max_cost_perturbation = 55 [default = 1e-07];
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(55, this->_internal_relative_max_cost_perturbation(), target);
  }

  // optional double max_number_of_reoptimizations = 56 [default = 40];
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(56, this->_internal_max_number_of_reoptimizations(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional .operations_research.glop.GlopParameters.ScalingAlgorithm scaling_method = 57 [default = EQUILIBRATION];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      57, this->_internal_scaling_method(), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional bool change_status_to_imprecise = 58 [default = true];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(58, this->_internal_change_status_to_imprecise(), target);
  }

  // optional double initial_condition_number_threshold = 59 [default = 1e+50];
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(59, this->_internal_initial_condition_number_threshold(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.glop.GlopParameters)
  return target;
}

size_t GlopParameters::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:operations_research.glop.GlopParameters)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bool use_dual_simplex = 31 [default = false];
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 + 1;
    }

    // optional bool allow_simplex_algorithm_change = 32 [default = false];
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 + 1;
    }

    // optional bool perturb_costs_in_dual_simplex = 53 [default = false];
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 + 1;
    }

    // optional .operations_research.glop.GlopParameters.ScalingAlgorithm scaling_method = 57 [default = EQUILIBRATION];
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_scaling_method());
    }

    // optional .operations_research.glop.GlopParameters.PricingRule feasibility_rule = 1 [default = STEEPEST_EDGE];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_feasibility_rule());
    }

    // optional .operations_research.glop.GlopParameters.PricingRule optimization_rule = 2 [default = STEEPEST_EDGE];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_optimization_rule());
    }

    // optional double refactorization_threshold = 6 [default = 1e-09];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 8;
    }

    // optional double recompute_reduced_costs_threshold = 8 [default = 1e-08];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 8;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional double recompute_edges_norm_threshold = 9 [default = 100];
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 8;
    }

    // optional double primal_feasibility_tolerance = 10 [default = 1e-08];
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 8;
    }

    // optional double dual_feasibility_tolerance = 11 [default = 1e-08];
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 8;
    }

    // optional double ratio_test_zero_threshold = 12 [default = 1e-09];
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 8;
    }

    // optional bool normalize_using_column_norm = 4 [default = true];
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional bool use_nested_pricing = 5 [default = true];
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 1;
    }

    // optional bool use_scaling = 16 [default = true];
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + 1;
    }

    // optional bool use_transposed_matrix = 18 [default = true];
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional .operations_research.glop.GlopParameters.InitialBasisHeuristic initial_basis = 17 [default = TRIANGULAR];
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_initial_basis());
    }

    // optional double harris_tolerance_ratio = 13 [default = 0.5];
    if (cached_has_bits & 0x00020000u) {
      total_size += 1 + 8;
    }

    // optional double small_pivot_threshold = 14 [default = 1e-06];
    if (cached_has_bits & 0x00040000u) {
      total_size += 1 + 8;
    }

    // optional double minimum_acceptable_pivot = 15 [default = 1e-06];
    if (cached_has_bits & 0x00080000u) {
      total_size += 1 + 8;
    }

    // optional int32 basis_refactorization_period = 19 [default = 64];
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_basis_refactorization_period());
    }

    // optional .operations_research.glop.GlopParameters.SolverBehavior solve_dual_problem = 20 [default = LET_SOLVER_DECIDE];
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_solve_dual_problem());
    }

    // optional double dualizer_threshold = 21 [default = 1.5];
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 + 8;
    }

    // optional double solution_feasibility_tolerance = 22 [default = 1e-06];
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 + 8;
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional double lu_factorization_pivot_threshold = 25 [default = 0.01];
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 + 8;
    }

    // optional double max_time_in_seconds = 26 [default = inf];
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 + 8;
    }

    // optional int64 max_number_of_iterations = 27 [default = -1];
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_max_number_of_iterations());
    }

    // optional double markowitz_singularity_threshold = 30 [default = 1e-15];
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 + 8;
    }

    // optional int32 markowitz_zlatev_parameter = 29 [default = 3];
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_markowitz_zlatev_parameter());
    }

    // optional int32 devex_weights_reset_period = 33 [default = 150];
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_devex_weights_reset_period());
    }

    // optional bool initialize_devex_with_column_norms = 36 [default = true];
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 + 1;
    }

    // optional bool exploit_singleton_column_in_initial_basis = 37 [default = true];
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 + 1;
    }

  }
  cached_has_bits = _has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    // optional bool provide_strong_optimal_guarantee = 24 [default = true];
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 + 1;
    }

    // optional bool change_status_to_imprecise = 58 [default = true];
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 + 1;
    }

    // optional bool use_preprocessing = 34 [default = true];
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 + 1;
    }

    // optional bool use_middle_product_form_update = 35 [default = true];
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 + 1;
    }

    // optional double dual_small_pivot_threshold = 38 [default = 0.0001];
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 + 8;
    }

    // optional double preprocessor_zero_tolerance = 39 [default = 1e-09];
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 + 8;
    }

    // optional double objective_lower_limit = 40 [default = -inf];
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 + 8;
    }

    // optional double objective_upper_limit = 41 [default = inf];
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 + 8;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional double degenerate_ministep_factor = 42 [default = 0.01];
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 + 8;
    }

    // optional int32 random_seed = 43 [default = 1];
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_random_seed());
    }

    // optional int32 num_omp_threads = 44 [default = 1];
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_num_omp_threads());
    }

    // optional double max_deterministic_time = 45 [default = inf];
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 + 8;
    }

    // optional double drop_tolerance = 52 [default = 1e-14];
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 + 8;
    }

    // optional double relative_cost_perturbation = 54 [default = 1e-05];
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 + 8;
    }

    // optional double relative_max_cost_perturbation = 55 [default = 1e-07];
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + 8;
    }

    // optional double max_number_of_reoptimizations = 56 [default = 40];
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 8;
    }

  }
  // optional double initial_condition_number_threshold = 59 [default = 1e+50];
  if (cached_has_bits & 0x00010000u) {
    total_size += 2 + 8;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GlopParameters::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:operations_research.glop.GlopParameters)
  GOOGLE_DCHECK_NE(&from, this);
  const GlopParameters* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<GlopParameters>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:operations_research.glop.GlopParameters)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:operations_research.glop.GlopParameters)
    MergeFrom(*source);
  }
}

void GlopParameters::MergeFrom(const GlopParameters& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:operations_research.glop.GlopParameters)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      use_dual_simplex_ = from.use_dual_simplex_;
    }
    if (cached_has_bits & 0x00000002u) {
      allow_simplex_algorithm_change_ = from.allow_simplex_algorithm_change_;
    }
    if (cached_has_bits & 0x00000004u) {
      perturb_costs_in_dual_simplex_ = from.perturb_costs_in_dual_simplex_;
    }
    if (cached_has_bits & 0x00000008u) {
      scaling_method_ = from.scaling_method_;
    }
    if (cached_has_bits & 0x00000010u) {
      feasibility_rule_ = from.feasibility_rule_;
    }
    if (cached_has_bits & 0x00000020u) {
      optimization_rule_ = from.optimization_rule_;
    }
    if (cached_has_bits & 0x00000040u) {
      refactorization_threshold_ = from.refactorization_threshold_;
    }
    if (cached_has_bits & 0x00000080u) {
      recompute_reduced_costs_threshold_ = from.recompute_reduced_costs_threshold_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      recompute_edges_norm_threshold_ = from.recompute_edges_norm_threshold_;
    }
    if (cached_has_bits & 0x00000200u) {
      primal_feasibility_tolerance_ = from.primal_feasibility_tolerance_;
    }
    if (cached_has_bits & 0x00000400u) {
      dual_feasibility_tolerance_ = from.dual_feasibility_tolerance_;
    }
    if (cached_has_bits & 0x00000800u) {
      ratio_test_zero_threshold_ = from.ratio_test_zero_threshold_;
    }
    if (cached_has_bits & 0x00001000u) {
      normalize_using_column_norm_ = from.normalize_using_column_norm_;
    }
    if (cached_has_bits & 0x00002000u) {
      use_nested_pricing_ = from.use_nested_pricing_;
    }
    if (cached_has_bits & 0x00004000u) {
      use_scaling_ = from.use_scaling_;
    }
    if (cached_has_bits & 0x00008000u) {
      use_transposed_matrix_ = from.use_transposed_matrix_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      initial_basis_ = from.initial_basis_;
    }
    if (cached_has_bits & 0x00020000u) {
      harris_tolerance_ratio_ = from.harris_tolerance_ratio_;
    }
    if (cached_has_bits & 0x00040000u) {
      small_pivot_threshold_ = from.small_pivot_threshold_;
    }
    if (cached_has_bits & 0x00080000u) {
      minimum_acceptable_pivot_ = from.minimum_acceptable_pivot_;
    }
    if (cached_has_bits & 0x00100000u) {
      basis_refactorization_period_ = from.basis_refactorization_period_;
    }
    if (cached_has_bits & 0x00200000u) {
      solve_dual_problem_ = from.solve_dual_problem_;
    }
    if (cached_has_bits & 0x00400000u) {
      dualizer_threshold_ = from.dualizer_threshold_;
    }
    if (cached_has_bits & 0x00800000u) {
      solution_feasibility_tolerance_ = from.solution_feasibility_tolerance_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      lu_factorization_pivot_threshold_ = from.lu_factorization_pivot_threshold_;
    }
    if (cached_has_bits & 0x02000000u) {
      max_time_in_seconds_ = from.max_time_in_seconds_;
    }
    if (cached_has_bits & 0x04000000u) {
      max_number_of_iterations_ = from.max_number_of_iterations_;
    }
    if (cached_has_bits & 0x08000000u) {
      markowitz_singularity_threshold_ = from.markowitz_singularity_threshold_;
    }
    if (cached_has_bits & 0x10000000u) {
      markowitz_zlatev_parameter_ = from.markowitz_zlatev_parameter_;
    }
    if (cached_has_bits & 0x20000000u) {
      devex_weights_reset_period_ = from.devex_weights_reset_period_;
    }
    if (cached_has_bits & 0x40000000u) {
      initialize_devex_with_column_norms_ = from.initialize_devex_with_column_norms_;
    }
    if (cached_has_bits & 0x80000000u) {
      exploit_singleton_column_in_initial_basis_ = from.exploit_singleton_column_in_initial_basis_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  cached_has_bits = from._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      provide_strong_optimal_guarantee_ = from.provide_strong_optimal_guarantee_;
    }
    if (cached_has_bits & 0x00000002u) {
      change_status_to_imprecise_ = from.change_status_to_imprecise_;
    }
    if (cached_has_bits & 0x00000004u) {
      use_preprocessing_ = from.use_preprocessing_;
    }
    if (cached_has_bits & 0x00000008u) {
      use_middle_product_form_update_ = from.use_middle_product_form_update_;
    }
    if (cached_has_bits & 0x00000010u) {
      dual_small_pivot_threshold_ = from.dual_small_pivot_threshold_;
    }
    if (cached_has_bits & 0x00000020u) {
      preprocessor_zero_tolerance_ = from.preprocessor_zero_tolerance_;
    }
    if (cached_has_bits & 0x00000040u) {
      objective_lower_limit_ = from.objective_lower_limit_;
    }
    if (cached_has_bits & 0x00000080u) {
      objective_upper_limit_ = from.objective_upper_limit_;
    }
    _has_bits_[1] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      degenerate_ministep_factor_ = from.degenerate_ministep_factor_;
    }
    if (cached_has_bits & 0x00000200u) {
      random_seed_ = from.random_seed_;
    }
    if (cached_has_bits & 0x00000400u) {
      num_omp_threads_ = from.num_omp_threads_;
    }
    if (cached_has_bits & 0x00000800u) {
      max_deterministic_time_ = from.max_deterministic_time_;
    }
    if (cached_has_bits & 0x00001000u) {
      drop_tolerance_ = from.drop_tolerance_;
    }
    if (cached_has_bits & 0x00002000u) {
      relative_cost_perturbation_ = from.relative_cost_perturbation_;
    }
    if (cached_has_bits & 0x00004000u) {
      relative_max_cost_perturbation_ = from.relative_max_cost_perturbation_;
    }
    if (cached_has_bits & 0x00008000u) {
      max_number_of_reoptimizations_ = from.max_number_of_reoptimizations_;
    }
    _has_bits_[1] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00010000u) {
    _internal_set_initial_condition_number_threshold(from._internal_initial_condition_number_threshold());
  }
}

void GlopParameters::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:operations_research.glop.GlopParameters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GlopParameters::CopyFrom(const GlopParameters& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:operations_research.glop.GlopParameters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GlopParameters::IsInitialized() const {
  return true;
}

void GlopParameters::InternalSwap(GlopParameters* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(_has_bits_[1], other->_has_bits_[1]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GlopParameters, perturb_costs_in_dual_simplex_)
      + sizeof(GlopParameters::perturb_costs_in_dual_simplex_)
      - PROTOBUF_FIELD_OFFSET(GlopParameters, use_dual_simplex_)>(
          reinterpret_cast<char*>(&use_dual_simplex_),
          reinterpret_cast<char*>(&other->use_dual_simplex_));
  swap(scaling_method_, other->scaling_method_);
  swap(feasibility_rule_, other->feasibility_rule_);
  swap(optimization_rule_, other->optimization_rule_);
  swap(refactorization_threshold_, other->refactorization_threshold_);
  swap(recompute_reduced_costs_threshold_, other->recompute_reduced_costs_threshold_);
  swap(recompute_edges_norm_threshold_, other->recompute_edges_norm_threshold_);
  swap(primal_feasibility_tolerance_, other->primal_feasibility_tolerance_);
  swap(dual_feasibility_tolerance_, other->dual_feasibility_tolerance_);
  swap(ratio_test_zero_threshold_, other->ratio_test_zero_threshold_);
  swap(normalize_using_column_norm_, other->normalize_using_column_norm_);
  swap(use_nested_pricing_, other->use_nested_pricing_);
  swap(use_scaling_, other->use_scaling_);
  swap(use_transposed_matrix_, other->use_transposed_matrix_);
  swap(initial_basis_, other->initial_basis_);
  swap(harris_tolerance_ratio_, other->harris_tolerance_ratio_);
  swap(small_pivot_threshold_, other->small_pivot_threshold_);
  swap(minimum_acceptable_pivot_, other->minimum_acceptable_pivot_);
  swap(basis_refactorization_period_, other->basis_refactorization_period_);
  swap(solve_dual_problem_, other->solve_dual_problem_);
  swap(dualizer_threshold_, other->dualizer_threshold_);
  swap(solution_feasibility_tolerance_, other->solution_feasibility_tolerance_);
  swap(lu_factorization_pivot_threshold_, other->lu_factorization_pivot_threshold_);
  swap(max_time_in_seconds_, other->max_time_in_seconds_);
  swap(max_number_of_iterations_, other->max_number_of_iterations_);
  swap(markowitz_singularity_threshold_, other->markowitz_singularity_threshold_);
  swap(markowitz_zlatev_parameter_, other->markowitz_zlatev_parameter_);
  swap(devex_weights_reset_period_, other->devex_weights_reset_period_);
  swap(initialize_devex_with_column_norms_, other->initialize_devex_with_column_norms_);
  swap(exploit_singleton_column_in_initial_basis_, other->exploit_singleton_column_in_initial_basis_);
  swap(provide_strong_optimal_guarantee_, other->provide_strong_optimal_guarantee_);
  swap(change_status_to_imprecise_, other->change_status_to_imprecise_);
  swap(use_preprocessing_, other->use_preprocessing_);
  swap(use_middle_product_form_update_, other->use_middle_product_form_update_);
  swap(dual_small_pivot_threshold_, other->dual_small_pivot_threshold_);
  swap(preprocessor_zero_tolerance_, other->preprocessor_zero_tolerance_);
  swap(objective_lower_limit_, other->objective_lower_limit_);
  swap(objective_upper_limit_, other->objective_upper_limit_);
  swap(degenerate_ministep_factor_, other->degenerate_ministep_factor_);
  swap(random_seed_, other->random_seed_);
  swap(num_omp_threads_, other->num_omp_threads_);
  swap(max_deterministic_time_, other->max_deterministic_time_);
  swap(drop_tolerance_, other->drop_tolerance_);
  swap(relative_cost_perturbation_, other->relative_cost_perturbation_);
  swap(relative_max_cost_perturbation_, other->relative_max_cost_perturbation_);
  swap(max_number_of_reoptimizations_, other->max_number_of_reoptimizations_);
  swap(initial_condition_number_threshold_, other->initial_condition_number_threshold_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GlopParameters::GetMetadata() const {
  return GetMetadataStatic();
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace glop
}  // namespace operations_research
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::operations_research::glop::GlopParameters* Arena::CreateMaybeMessage< ::operations_research::glop::GlopParameters >(Arena* arena) {
  return Arena::CreateMessageInternal< ::operations_research::glop::GlopParameters >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
